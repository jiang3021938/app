import logging
from datetime import datetime, timedelta
from fastapi import APIRouter, Depends, HTTPException, Request
from pydantic import BaseModel
from sqlalchemy.ext.asyncio import AsyncSession
import stripe

from core.database import get_db
from dependencies.auth import get_current_user
from schemas.auth import UserResponse
from services.payments import PaymentsService
from services.user_credits import User_creditsService
from core.config import settings

stripe.api_key = settings.stripe_secret_key

router = APIRouter(prefix="/api/v1/payment", tags=["payment"])

logger = logging.getLogger(__name__)

# Pricing configuration
PRICING = {
    "single": {
        "price": 900,  # $9.00 in cents
        "credits": 1,
        "name": "Single Analysis",
        "description": "One lease document analysis"
    },
    "pack5": {
        "price": 2900,  # $29.00 in cents
        "credits": 5,
        "name": "5-Pack Analysis",
        "description": "Five lease document analyses"
    },
    "monthly": {
        "price": 2900,  # $29.00 in cents
        "credits": 5,
        "name": "Monthly Subscription",
        "description": "5 analyses per month, renews monthly"
    }
}


class CheckoutRequest(BaseModel):
    plan_type: str  # single, pack5, monthly
    success_url: str
    cancel_url: str


class CheckoutResponse(BaseModel):
    session_id: str
    url: str


class PaymentVerifyRequest(BaseModel):
    session_id: str


class PaymentStatusResponse(BaseModel):
    status: str
    credits_added: int = 0
    message: str


@router.post("/create_checkout_session", response_model=CheckoutResponse)
async def create_checkout_session(
    data: CheckoutRequest,
    request: Request,
    current_user: UserResponse = Depends(get_current_user),
    db: AsyncSession = Depends(get_db),
):
    """Create a Stripe checkout session for purchasing credits"""
    try:
        if data.plan_type not in PRICING:
            raise HTTPException(status_code=400, detail="Invalid plan type")
        
        plan = PRICING[data.plan_type]
        
        # Get frontend host
        frontend_host = request.headers.get("App-Host")
        if frontend_host and not frontend_host.startswith(("http://", "https://")):
            frontend_host = f"https://{frontend_host}"
        
        # Create line items
        line_items = [{
            "price_data": {
                "currency": "usd",
                "product_data": {
                    "name": plan["name"],
                    "description": plan["description"],
                },
                "unit_amount": plan["price"],
            },
            "quantity": 1,
        }]
        
        # Determine mode based on plan type
        mode = "subscription" if data.plan_type == "monthly" else "payment"
        
        # For subscription, we need to set up recurring
        if data.plan_type == "monthly":
            line_items[0]["price_data"]["recurring"] = {"interval": "month"}
        
        # Create Stripe checkout session
        session = stripe.checkout.Session.create(
            payment_method_types=["card"],
            line_items=line_items,
            mode=mode,
            success_url=f"{frontend_host}/payment-success?session_id={{CHECKOUT_SESSION_ID}}",
            cancel_url=f"{frontend_host}/pricing",
            metadata={
                "user_id": current_user.id,
                "plan_type": data.plan_type,
                "credits": str(plan["credits"])
            }
        )
        
        # Create payment record
        payments_service = PaymentsService(db)
        await payments_service.create({
            "user_id": current_user.id,
            "stripe_session_id": session.id,
            "amount": plan["price"],
            "currency": "usd",
            "payment_type": "subscription" if data.plan_type == "monthly" else "single",
            "credits_purchased": plan["credits"],
            "status": "pending",
            "created_at": datetime.now()
        }, current_user.id)
        
        return CheckoutResponse(
            session_id=session.id,
            url=session.url
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Checkout session error: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/verify_payment", response_model=PaymentStatusResponse)
async def verify_payment(
    data: PaymentVerifyRequest,
    current_user: UserResponse = Depends(get_current_user),
    db: AsyncSession = Depends(get_db),
):
    """Verify payment and add credits to user account"""
    try:
        # Retrieve session from Stripe
        session = stripe.checkout.Session.retrieve(data.session_id)
        
        # Get payment record
        payments_service = PaymentsService(db)
        payment = await payments_service.get_by_field("stripe_session_id", data.session_id)
        
        if not payment:
            raise HTTPException(status_code=404, detail="Payment record not found")
        
        # Check if already processed
        if payment.status == "completed":
            return PaymentStatusResponse(
                status="completed",
                credits_added=payment.credits_purchased or 0,
                message="Payment already processed"
            )
        
        # Check payment status
        if session.payment_status != "paid":
            return PaymentStatusResponse(
                status="pending",
                credits_added=0,
                message="Payment not yet completed"
            )
        
        # Update payment status
        await payments_service.update(payment.id, {
            "status": "completed"
        }, current_user.id)
        
        # Add credits to user
        credits_service = User_creditsService(db)
        user_credits = await credits_service.get_by_field("user_id", current_user.id)
        
        plan_type = session.metadata.get("plan_type", "single")
        credits_to_add = int(session.metadata.get("credits", 1))
        
        if user_credits:
            update_data = {
                "paid_credits": (user_credits.paid_credits or 0) + credits_to_add,
                "updated_at": datetime.now()
            }
            
            # Handle subscription
            if plan_type == "monthly":
                update_data["subscription_type"] = "monthly"
                update_data["subscription_expires_at"] = datetime.now() + timedelta(days=30)
            
            await credits_service.update(user_credits.id, update_data, current_user.id)
        else:
            create_data = {
                "user_id": current_user.id,
                "free_credits": 0,
                "paid_credits": credits_to_add,
                "subscription_type": "monthly" if plan_type == "monthly" else "none",
                "created_at": datetime.now(),
                "updated_at": datetime.now()
            }
            if plan_type == "monthly":
                create_data["subscription_expires_at"] = datetime.now() + timedelta(days=30)
            
            await credits_service.create(create_data, current_user.id)
        
        return PaymentStatusResponse(
            status="completed",
            credits_added=credits_to_add,
            message=f"Successfully added {credits_to_add} credits to your account"
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Payment verification error: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/pricing")
async def get_pricing():
    """Get available pricing plans"""
    return {
        "plans": [
            {
                "id": "single",
                "name": PRICING["single"]["name"],
                "description": PRICING["single"]["description"],
                "price": PRICING["single"]["price"] / 100,
                "credits": PRICING["single"]["credits"],
                "popular": False
            },
            {
                "id": "pack5",
                "name": PRICING["pack5"]["name"],
                "description": PRICING["pack5"]["description"],
                "price": PRICING["pack5"]["price"] / 100,
                "credits": PRICING["pack5"]["credits"],
                "popular": True
            },
            {
                "id": "monthly",
                "name": PRICING["monthly"]["name"],
                "description": PRICING["monthly"]["description"],
                "price": PRICING["monthly"]["price"] / 100,
                "credits": PRICING["monthly"]["credits"],
                "popular": False,
                "recurring": True
            }
        ]
    }